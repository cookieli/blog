---
layout: post
title: "aries读书笔记"
comments: true
description: "aries 论文的读书笔记"
keywords: "dummy content"
author: GuestName
---
1. 简介部分
### Logging, failure and Recovery Methods
对于log:
作用: 记录transaction的进度。可以被用来恢复已commit但由于crash或failure而丢失的数据，也可以用来撤销未commit的transaction对系统的改变.<br/>
概念:log可以被理解为线性的增长的文件，每个log都会被给予一个LSN(log sequence number),LSN以增长的方式赋予<br/>
写入过程:log 会最先被写入volatile storage中，待到特定的时间点:例如commit的时候在某个lsn之前的log会被强制写入stable storage中，这个过程称为force.也可以在后端阶段性的写入<br/>
Log通常只记录一个页，但也有例外.<br/>
Log会以undo或者redo分类<br/>
记录信息方式:<br/>
1. physically: 例如会记录某个特定值更新前后更新后的映像<br/>
2. operationally: 例如记录为record 5的field 3加5<br/>
对于 WAL protocal:<br/>
1. in-place updating: 更新的页会覆盖stable storage上原先的页<br/>
2. 在记录某页更新的信息的log被写入stable storage之前相关的页不能被写入stable storage<br/>
transaction与log:<br/>
transaction的状态也会被记录到log中，transaction只有在其commit status和相关的log都被写入到stable storage之后才会被认为commit.<br/>
这可用来恢复一个已提交的transaction但是相关页没有被更新到stable storage中.<br/>
以上过程也可以理解为只有一个transaction的所有redo信息被记录到stable storage后才可以被认为已提交<br/>
transaction运行时的相关概念;<br/>
forward processing: system在正常状态,transaction正在更新系统，没有回滚，没有基于log的undo<br/>
partial rollback: 在执行的时候建立一个savepoint，然后transaction被要求回滚的时候回到上一个savepoint<br/>
total rollbalck: 整个transaction所有的更新都被undone，然后终止<br/>
nested rollback: 一个接一个的回滚<br/>
normal undo:一个系统在正常状态下某个transaction被要求回滚，一般发生在transaction request或者检测到deadlock或者不满足限制性条件的时候<br/>
Restart undo:顾名思义<br/>
所有被一个transaction写的所有log都由preLSN连接起来<br/>
在许多WAL系统中，回滚过程中所进行的所有更新都被compensation log records记录<br/>
Page-oriented redo描述了一个log record记录了哪个页在normal processing中被修改以及在redo过程中需要对该页进行处理, 该log正在被执行redo的过程称为page-oriented redo<br/>
page oriented redo 在执行过程中不需要访问索引和table的内部结构.<br/>
但是logical redo会需要访问数据库的内部结构和索引，甚至需要对索引进行修改，由此有可能会访问多个页.<br/>
page oriented redo可以允许系统提供recovery independence from object.<br/>即对一个页的修改不需要访问其他页<br/>
logical系列操作能提供更高的并发性，page-oriented能提供更好的recovery.<br/>
### Latches and Locks
latch类似于信号量，可以用来保证数据的物理一致性，而lock用来保证数据的逻辑一致性。<br/>
latch被持有的时间一般比较短，所以deadlock不考虑相关情况.<br/>
latch一般操作代价会比lock小很多.因为latch一般在virtual memory的固定位置存储，而且基于latch的name可寻址，一般transaction保有的latch数目很少，所以latch request block可以被永久的开辟给一个transaction,而且用transaction ID初始化.<br/>
lock需要被动态的开辟，格式化和收回,由于lock的数目比较多，一般transaction会保有一个hash table用于获得相关lock的信息.<br/>
lock的模式，前面博客里提到过<br/>
Lock的request 分为conditioal和unconditional.<br/>
conditional意味着如果lock不会被立即授予的话， 请求者不会wait,而unconditional则相反.<br/>
lock有着持续时长，instant lock意味这lock不会被实际授予，但是lock manager会推迟返回lock call直到lock可授予.<br/>
commit duration是指lock直到transaction终止的时候才会被释放.<br/>
manual lock指的是中间情况.<br/>
### aries系统整体概况

aries使用log记录对数据库的变化，使用wal机制，同时在rollback过程中使用log进行记录,(compensation log records CLRs).<br/>
即在undo过程中诞生CLRs,<br/>
在aries中，CLRs是redo-only log records, 在forward procesiing中将有效的clrs嵌入到log records中，能有效的保证TT在回滚过程中log数目的有限性.<br/>
具体过程如图:<br/>
![](https://raw.githubusercontent.com/cookieli/image/master/database/clrsLogGen.png) 
如果clrs是undo log,会在未来的多次failure中产生一大堆对于以前clrs log的clrs log，影响性能.<br/>
![](https://raw.githubusercontent.com/cookieli/image/master/database/undoCLRs_problem.png) 
那么在aries中该问题是如何被解决的:<br/>
在clr中有一个UndoNXTLSN，指向恰好撤销的Log的先序节点，该节点决定了一个transaction中还有多少未被撤销.<br/>
因此在rollbakck过程中，clr的 undoNXTLSN追踪这rollback的进程，它告诉系统从哪里开始继续回滚，如果一个回滚过程失败或者有nested rollback，系统可以根据这个undoNXTLSN来绕过那些已经undone的log.<br/>
具体情况如图所示;<br/>
![](https://raw.githubusercontent.com/cookieli/image/master/database/undologForAries.png) 
由于clrs能够很好的记录undo过程中采取的行动，我们可以不必将undo限定为对某一特定页的相关行为的反转,而clrs的redo则是对特定页的行为的描述，提高了其高效性.<br/>
aries将相关log的lsn放置入相关page的lsn中.<br/>
aries阶段性的建立checkpoint log. checkpoint log用来判别哪些transaction还在活跃，其相关的最新的log的lsn,还有在bufferPool中被修改的数据.<br/>
restart recovery过程:<br/>
第一步:analysis pass: 在checkpoint 和log结束之前的正在进行的transaction和dirty page信息被更新.<br/>
analysis pass利用dirty page的信息确定在接下来的redo pass中进行log scan的起始点.redoLSN<br/>
同时它还确定在undo pass中回滚的transaction的列表.<br/>
第二步: redo pass:<br/>
对于每一个其更新已经被log到stable storage上，但是其对于数据库相关页的影响还没有被储存在nonvolitile storage上的操作，系统重复其历史，这个过程要对所有transaction redo.<br/>包括那些既没有被提交也没有在2-phase commit中到达in-doubt 状态的transaction.<br/>一个log record 的更新要被 redo取决于其所影响的page的lsn小于log record对应的lsn.<br/>
下一步是undo pass:<br/>
在对log们进行单向的逆序的扫描过程中，要对所有的loser transction进行undo.<br/>
将每个没有完全撤销的的loser transaction,不断的处理具有最大lsn的log,直到transaction被处理完毕。<br/>
undo是一定会被操作的，不会通过判断page的lsn和log的lsn进行判断，如果遇到redo-undo log, undo-only log,其对应的更新一定会被撤销，如果遇到clr，则会跳过，找undoNxtLSN.<br/>
对于那些已经部分回滚的transaction,aries仅仅会回滚那些还没有回滚的操作。这是由于clr可以指向上一个没有被undo的log.<br/>
而只要涉及到基于页的undo和 logical log只产生对应的clr,那么clr的数目将会完全等同于undoable log的数目.<br/>
### Data structures
列举: LSN， Type, transID，PrevsLSN, PageID，UndoNxtLSN, Data.<br/>


